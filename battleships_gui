import pygame
import random
from time import sleep
pygame.init()

WIN_WIDTH, WIN_HEIGHT = 700, 580
BF_WIDTH, BF_HEIGHT = 240, 240

CELL_COLOR = (200, 200, 200)
SELECTED_COLOR = (255, 73, 83)
LOCKED_COLOR = (83, 255, 73)
LINE_COLOR = (0, 0, 0)
BG_COLOR = (80, 80, 80)

FPS = 60
EDGE = 5

WIN = pygame.display.set_mode((WIN_WIDTH, WIN_HEIGHT))
FONT = pygame.font.SysFont('Comic Sans', 4 * EDGE)

PLAYER_TEXT = FONT.render('Player\'s board:', True, (0, 0, 0))
OPP_TEXT = FONT.render('Opponent\'s board:', True, (0, 0, 0))

MSG_PLAYER_MISS = 'You missed.'
MSG_PLAYER_TURN = 'Your turn.'
MSG_OPP_TURN = 'Opponent\'s turn.'
MSG_PICK_CELL = 'Pick a cell to shoot at.'
MSG_PICK_ANOTHER = 'Pick another cell.'
MSG_HIT = 'Great, It\'s a hit!'
MSG_MOVE_REPEAT = 'You already shot this cell.'
MSG_LETS_PLAY = 'Let\'s play Battleship!'
MSG_EMPTY = ''
MSG_PLAYER_NO_SHIPS = 'All player\'s ships destroyed!'
MSG_OPP_WINS = 'Opponent wins!'
MSG_OPP_NO_SHIPS = 'All opponent\'s ships destroyed!'
MSG_PLAYER_WINS = 'You win!'
MSG_LEGEND = 'Legend:'
MSG_SELECT = 'Use ARROWS or CLICK to select cells'
MSG_LOCK = 'Press SPACE BAR to lock the cell'
MSG_PLACE_SHIP = 'Press ENTER to place the ship'
MSG_ATTACK = 'Press ENTER to attack selected cell'

LEGEND_PLACEMENT = [MSG_LEGEND, MSG_SELECT, MSG_LOCK, MSG_PLACE_SHIP]
LEGEND_SHOOTING = [MSG_LEGEND, MSG_SELECT, MSG_ATTACK]

TARGET_HIT = 'X'
TARGET_MISSED = '-'
TARGET_REVEALED = 'O'
EMPTY_CELL = ''

SHIPS = [6, 4, 4, 3, 3, 2, 2]
HITS = sum(SHIPS)


class Battlefield:
    width = BF_WIDTH
    height = BF_HEIGHT
    window = WIN

    def __init__(self, rows, cols, h_offset):
        self.rows = rows
        self.cols = cols
        self.h_offset = h_offset
        self.cells = [[Cell(i, j, self.width, self.height, self.h_offset)
                       for i in range(self.rows)]
                      for j in range(self.cols)]
        self.selected = None
        self.locked = []
        self.moves = []
        self.adjacent = []
        self.hits_left = HITS

    def draw(self):
        for x in range(self.rows):
            for y in range(self.cols):
                self.cells[x][y].draw()

        gap = self.width / 10
        for x in range(self.rows + 1):
            pygame.draw.line(self.window, LINE_COLOR,
                             (0, self.h_offset + x * gap),
                             (self.width, self.h_offset + x * gap), 2)
        for x in range(self.cols+1):
            pygame.draw.line(self.window, LINE_COLOR, (x * gap, self.h_offset),
                             (x * gap, self.height + self.h_offset), 2)

    def select_cell(self, row, col):
        self.cells[row][col].selected = True
        self.selected = (row, col)

    def deselect_cells(self):
        for x in range(self.rows):
            for y in range(self.cols):
                self.cells[x][y].selected = False
        self.selected = None

    def get_cell(self, pos):
        if pos[0] < self.width and 0 < pos[1] - self.h_offset < self.height:
            gap = self.width // 10
            x = pos[0] // gap
            y = (pos[1] - self.h_offset) // gap
            return int(y), int(x)
        else:
            return None

    def move_arrows(self, direction):
        row, col = self.selected
        if direction == 'up':
            if row > 0:
                self.selected = (self.selected[0] - 1, self.selected[1])
                self.cells[row - 1][col].selected = True
                self.cells[row][col].selected = False
        if direction == 'down':
            if row < 9:
                self.selected = (self.selected[0] + 1, self.selected[1])
                self.cells[row + 1][col].selected = True
                self.cells[row][col].selected = False
        if direction == 'left':
            if col > 0:
                self.selected = (self.selected[0], self.selected[1] - 1)
                self.cells[row][col - 1].selected = True
                self.cells[row][col].selected = False
        if direction == 'right':
            if col < 9:
                self.selected = (self.selected[0], self.selected[1] + 1)
                self.cells[row][col + 1].selected = True
                self.cells[row][col].selected = False


class PlayerField(Battlefield):
    def lock_cell(self):
        row, col = self.selected
        if self.cells[row][col].locked:
            self.cells[row][col].locked = False
            self.locked.remove((row, col))
        else:
            self.cells[row][col].locked = True
            self.locked.append((row, col))

    def unlock_cells(self):
        for x in range(self.rows):
            for y in range(self.cols):
                self.cells[x][y].locked = False
        self.locked = []

    def opponents_turn(self):
        miss = False
        while not miss:
            if self.adjacent:
                x, y = self.adjacent.pop(random.randint(0,
                                                        len(self.adjacent)-1))
            else:
                x, y = [random.randint(0, 9) for _ in range(2)]

            if (x, y) in self.moves:
                continue
            self.moves.append((x, y))

            if self.cells[x][y].value:
                self.cells[x][y].value = TARGET_HIT
                self.hits_left -= 1

                if x > 0:
                    self.adjacent.append((x - 1, y))
                if x < 9:
                    self.adjacent.append((x + 1, y))
                if y > 0:
                    self.adjacent.append((x, y - 1))
                if y < 9:
                    self.adjacent.append((x, y + 1))
                continue
            else:
                self.cells[x][y].value = TARGET_MISSED
                miss = True

    def is_placement_correct(self, ship_list):
        ship = ship_list[0]
        if len(self.locked) == ship:

            x_values = [self.locked[x][0] for x in range(len(self.locked))]
            y_values = [self.locked[x][1] for x in range(len(self.locked))]

            x_range = range(max(0, min(x_values) - 1),
                            min(max(x_values) + 2, 10))
            y_range = range(max(0, min(y_values) - 1),
                            min(max(y_values) + 2, 10))

            if not any(self.cells[x][y].value
                       for x in x_range for y in y_range):
                rows = []
                cols = []
                for x, y in self.locked:
                    rows.append(x)
                    cols.append(y)
                    self.cells[x][y].locked = False

                if len(set(rows)) == 1 and sum(set(cols)) == \
                        sum([min(cols) + i for i in range(ship)]):
                    for x, y in self.locked:
                        self.cells[x][y].value = TARGET_REVEALED
                elif len(set(cols)) == 1 and sum(set(rows)) == \
                        sum([min(rows) + i for i in range(ship)]):
                    for x, y in self.locked:
                        self.cells[x][y].value = TARGET_REVEALED
                ship_list.pop(0)
        self.unlock_cells()
        if not ship_list:
            self.deselect_cells()


class OpponentField(Battlefield):
    def __init__(self, rows, cols, h_offset):
        super().__init__(rows, cols, h_offset)

        for x in range(self.rows):
            for y in range(self.cols):
                self.cells[x][y].visible = False

    def place_ships(self):
        opp_ships = SHIPS[:]
        while opp_ships:
            ship_len = opp_ships[0]
            direction = random.choice(['horizontal', 'vertical'])
            x, y = [random.randint(0, 9) for _ in range(2)]

            if direction == 'horizontal':
                range_x = range(max(0, x - 1), min(x + ship_len + 1, 10))
                range_y = range(max(0, y - 1), min(y + 2, 10))
                if len(range_x) < ship_len + 1 or len(range_y) < 2:
                    continue
                if any(self.cells[row][col].value for row in range_y
                       for col in range_x):
                    continue
                for num in range(x, x + ship_len):
                    self.cells[y][num].value = TARGET_REVEALED
            elif direction == 'vertical':
                range_x = range(max(0, x - 1), min(x + 2, 10))
                range_y = range(max(0, y - 1), min(y + ship_len + 1, 10))
                if len(range_x) < 2 or len(range_y) < ship_len + 1:
                    continue
                if any(self.cells[row][col].value for row in range_y
                       for col in range_x):
                    continue
                for num in range(y, y + ship_len):
                    self.cells[num][x].value = TARGET_REVEALED
            opp_ships.pop(0)

    def is_repeated_move(self):
        if self.selected:
            x, y = self.selected
            if (x, y) in self.moves:
                return True

    def shoot(self):
        if self.selected:
            x, y = self.selected
            if (x, y) not in self.moves:
                self.moves.append((x, y))
                self.cells[x][y].visible = True
                if self.cells[x][y].value:
                    self.cells[x][y].value = TARGET_HIT
                    self.hits_left -= 1
                else:
                    self.cells[x][y].value = TARGET_MISSED
                    return True


class Cell:
    color = CELL_COLOR

    def __init__(self, row, col, bf_width, bf_height, h_offset):
        self.value = None
        self.row = row
        self.col = col
        self.h_offset = h_offset
        self.bf_width = bf_width
        self.bf_height = bf_height
        self.selected = False
        self.locked = False
        self.visible = True

    def draw(self):
        gap = self.bf_width / 10
        x = self.row * gap
        y = self.col * gap
        pygame.draw.rect(WIN, self.color, (x, y + self.h_offset, gap, gap))

        if self.value and self.visible:
            text = FONT.render(self.value, True, (0, 0, 0))
            WIN.blit(text, (x + 5, y + self.h_offset - 2))

        if self.selected:
            pygame.draw.rect(WIN, SELECTED_COLOR,
                             (x, y + self.h_offset, gap, gap), 3)

        if self.locked:
            pygame.draw.rect(WIN, LOCKED_COLOR,
                             (x, y + self.h_offset, gap, gap), 3)


def draw_window(player, opp, msg, msg2, show_legend=False, ships_placed=False):
    pygame.display.set_mode((WIN_WIDTH, WIN_HEIGHT))

    WIN.fill(BG_COLOR)

    player.draw()
    opp.draw()

    draw_text(f'Player\'s board: ({HITS-player.hits_left}/'
              f'{HITS} hits)', EDGE, EDGE)
    draw_text(f'Opponent\'s board: ({HITS-opp.hits_left}/{HITS} '
              f'hits)', EDGE,
              3 * EDGE + BF_HEIGHT + PLAYER_TEXT.get_height())
    if ships_placed:
        draw_text(msg, BF_WIDTH + 16 * EDGE, 3 * EDGE + BF_HEIGHT +
                  PLAYER_TEXT.get_height())
        draw_text(msg2, BF_WIDTH + 16 * EDGE, 9 * EDGE + BF_HEIGHT +
                  PLAYER_TEXT.get_height())
    else:
        draw_text(msg, BF_WIDTH + 16 * EDGE, EDGE)
        draw_text(msg2, BF_WIDTH + 16 * EDGE, 7 * EDGE)

    if show_legend:
        if ships_placed:
            for i, text in enumerate(LEGEND_SHOOTING):
                draw_text(text, BF_WIDTH + 16 * EDGE, 28 * EDGE + BF_HEIGHT +
                          PLAYER_TEXT.get_height() + 6 * i * EDGE)
        else:
            for i, text in enumerate(LEGEND_PLACEMENT):
                draw_text(text, BF_WIDTH + 16 * EDGE, 18 * EDGE + 6 * i * EDGE)

    pygame.display.flip()


def game_status(player, opp):
    if not player.hits_left:
        draw_window(player, opp, MSG_PLAYER_NO_SHIPS, MSG_OPP_WINS)
        sleep(3)
        quit()
    elif not opp.hits_left:
        draw_window(player, opp, MSG_OPP_NO_SHIPS, MSG_PLAYER_WINS)
        sleep(3)
        quit()


def draw_text(string, x, y):
    msg = FONT.render(string, True, (0, 0, 0))
    WIN.blit(msg, (x, y))


def main():
    run = True
    hit = False
    move_repeated = False
    ships_remaining = SHIPS[:]
    pygame.display.set_caption('Battleship')
    player_field = PlayerField(10, 10, PLAYER_TEXT.get_height() + 2 * EDGE)
    opponent_field = OpponentField(10, 10, PLAYER_TEXT.get_height() +
                                   4 * EDGE + BF_HEIGHT + OPP_TEXT.get_height())

    opponent_field.place_ships()

    draw_window(player_field, opponent_field, MSG_LETS_PLAY, MSG_EMPTY,
                False, False)
    sleep(2)

    while run:
        if ships_remaining:
            draw_window(player_field, opponent_field,
                        f'Place the ship of size {ships_remaining[0]}', 
                        EMPTY_CELL, True, False)
        else:
            if move_repeated:
                draw_window(player_field, opponent_field,
                            MSG_MOVE_REPEAT, MSG_PICK_ANOTHER, True, True)
            elif hit:
                draw_window(player_field, opponent_field,
                            MSG_HIT, MSG_PICK_ANOTHER, True, True)
            else:
                draw_window(player_field, opponent_field,
                            MSG_PLAYER_TURN, MSG_PICK_CELL, True, True)

        keys = pygame.key.get_pressed()
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                run = False
            if keys[pygame.K_q]:
                run = False
            if event.type == pygame.MOUSEBUTTONDOWN:
                pos = pygame.mouse.get_pos()
                player_clicked = player_field.get_cell(pos)
                opp_clicked = opponent_field.get_cell(pos)
                player_field.deselect_cells()
                opponent_field.deselect_cells()
                if player_clicked and ships_remaining:
                    player_field.select_cell(player_clicked[0], 
                                             player_clicked[1])
                elif opp_clicked and not ships_remaining:
                    opponent_field.select_cell(opp_clicked[0], opp_clicked[1])
            if event.type == pygame.KEYDOWN:
                if player_field.selected and ships_remaining:
                    if event.key == pygame.K_UP:
                        player_field.move_arrows('up')
                    if event.key == pygame.K_DOWN:
                        player_field.move_arrows('down')
                    if event.key == pygame.K_LEFT:
                        player_field.move_arrows('left')
                    if event.key == pygame.K_RIGHT:
                        player_field.move_arrows('right')
                    if event.key == pygame.K_SPACE:
                        player_field.lock_cell()
                    if event.key == pygame.K_DELETE:
                        player_field.locked = []
                    if event.key == pygame.K_RETURN:
                        player_field.is_placement_correct(ships_remaining)
                if opponent_field.selected and not ships_remaining:
                    if event.key == pygame.K_UP:
                        opponent_field.move_arrows('up')
                    if event.key == pygame.K_DOWN:
                        opponent_field.move_arrows('down')
                    if event.key == pygame.K_LEFT:
                        opponent_field.move_arrows('left')
                    if event.key == pygame.K_RIGHT:
                        opponent_field.move_arrows('right')
                    if event.key == pygame.K_RETURN:
                        if opponent_field.is_repeated_move():
                            move_repeated = True
                        else:
                            move_repeated = False
                            player_missed = opponent_field.shoot()
                            game_status(player_field, opponent_field)
                            if player_missed:
                                hit = False
                                draw_window(player_field, opponent_field,
                                            MSG_PLAYER_MISS, MSG_OPP_TURN,
                                            True, True)
                                sleep(1.5)
                                player_field.opponents_turn()
                                game_status(player_field, opponent_field)
                            else:
                                hit = True


if __name__ == '__main__':
    main()
