import pygame
import random
from time import sleep
pygame.init()

WIN_WIDTH, WIN_HEIGHT = 600, 600
BF_WIDTH, BF_HEIGHT = 240, 240

CELL_COLOR = (200, 200, 200)
SELECTED_COLOR = (255, 73, 83)
LOCKED_COLOR = (83, 255, 73)
LINE_COLOR = (0, 0, 0)
BG_COLOR = (80, 80, 80)

WIN = pygame.display.set_mode((WIN_WIDTH, WIN_HEIGHT))
FONT = pygame.font.SysFont('Comic Sans', 20)

FPS = 60
EDGE = 10

PLAYER_TEXT = FONT.render('Player\'s board:', True, (0, 0, 0))
OPP_TEXT = FONT.render('Opponent\'s board:', True, (0, 0, 0))

MSG_PLAYER_MISS = 'You missed.'
MSG_PLAYER_TURN = 'Your turn.'
MSG_OPP_TURN = 'Opponent\'s turn.'
MSG_PICK_CELL = 'Pick a cell to shoot at.'
MSG_PICK_ANOTHER = 'Pick another cell.'
MSG_HIT = 'Great, It\'s a hit!'
MSG_MOVE_REPEAT = 'You already shot this cell.'
MSG_LETS_PLAY = 'Let\'s play Battleship!'
MSG_EMPTY = ''
MSG_PLAYER_NO_SHIPS = 'All player\'s ships destroyed!'
MSG_OPP_WINS = 'Opponent wins!'
MSG_OPP_NO_SHIPS = 'All opponent\'s ships destroyed!'
MSG_PLAYER_WINS = 'You win!'

TARGET_HIT = 'X'
TARGET_MISSED = '-'
TARGET_REVEALED = 'O'
EMPTY_CELL = ''

SHIPS = [6, 4, 4, 3, 3, 2, 2]
HITS = sum(SHIPS)


class Battlefield:
    width = BF_WIDTH
    height = BF_HEIGHT
    window = WIN

    def __init__(self, rows, cols, h_offset):
        self.rows = rows
        self.cols = cols
        self.h_offset = h_offset
        self.cells = [[Cell(i, j, self.width, self.height, self.h_offset)
                       for i in range(self.rows)]
                      for j in range(self.cols)]
        self.selected = None
        self.locked = []
        self.moves = []
        self.adjacent = []
        self.hits_left = HITS

    def draw(self):
        for x in range(self.rows):
            for y in range(self.cols):
                self.cells[x][y].draw()

        gap = self.width / 10
        for x in range(self.rows + 1):
            pygame.draw.line(self.window, LINE_COLOR,
                             (0, self.h_offset + x * gap),
                             (self.width, self.h_offset + x * gap), 2)
        for x in range(self.cols+1):
            pygame.draw.line(self.window, LINE_COLOR, (x * gap, self.h_offset),
                             (x * gap, self.height + self.h_offset), 2)

    def select_cell(self, row, col):
        self.cells[row][col].selected = True
        self.selected = (row, col)

    def deselect_cells(self):
        for x in range(self.rows):
            for y in range(self.cols):
                self.cells[x][y].selected = False
        self.selected = None

    def lock_cell(self):
        row, col = self.selected
        if self.cells[row][col].locked:
            self.cells[row][col].locked = False
            self.locked.remove((row, col))
        else:
            self.cells[row][col].locked = True
            self.locked.append((row, col))

    def unlock_cells(self):
        for x in range(self.rows):
            for y in range(self.cols):
                self.cells[x][y].locked = False
        self.locked = []

    def opps_turn(self):
        miss = False
        while not miss:
            if self.adjacent:
                x, y = self.adjacent.pop(random.randint(0,
                                                        len(self.adjacent)-1))
            else:
                x, y = [random.randint(0, 9) for _ in range(2)]

            if (x, y) in self.moves:
                continue
            self.moves.append((x, y))

            if self.cells[x][y].value:
                self.cells[x][y].value = TARGET_HIT
                self.hits_left -= 1

                if x > 0:
                    self.adjacent.append((x - 1, y))
                if x < 9:
                    self.adjacent.append((x + 1, y))
                if y > 0:
                    self.adjacent.append((x, y - 1))
                if y < 9:
                    self.adjacent.append((x, y + 1))
                continue
            else:
                self.cells[x][y].value = TARGET_MISSED
                miss = True

    def evaluate_selected(self, ship_list):
        ship = ship_list[0]
        if len(self.locked) == ship:

            x_values = [self.locked[x][0] for x in range(len(self.locked))]
            y_values = [self.locked[x][1] for x in range(len(self.locked))]

            x_range = range(max(0, min(x_values) - 1),
                            min(max(x_values) + 2, 10))
            y_range = range(max(0, min(y_values) - 1),
                            min(max(y_values) + 2, 10))

            if not any(self.cells[x][y].value
                       for x in x_range for y in y_range):
                rows = []
                cols = []
                for x, y in self.locked:
                    rows.append(x)
                    cols.append(y)
                    self.cells[x][y].locked = False

                if len(set(rows)) == 1 and sum(set(cols)) == \
                        sum([min(cols) + i for i in range(ship)]):
                    for x, y in self.locked:
                        self.cells[x][y].value = TARGET_REVEALED
                elif len(set(cols)) == 1 and sum(set(rows)) == \
                        sum([min(rows) + i for i in range(ship)]):
                    for x, y in self.locked:
                        self.cells[x][y].value = TARGET_REVEALED
                ship_list.pop(0)
        self.unlock_cells()
        if not ship_list:
            self.deselect_cells()

    def get_cell(self, pos):
        if pos[0] < self.width and 0 < pos[1] - self.h_offset < self.height:
            gap = self.width // 10
            x = pos[0] // gap
            y = (pos[1] - self.h_offset) // gap
            return int(y), int(x)
        else:
            return None

    def move_arrows(self, direction):
        row, col = self.selected
        if direction == 'up':
            if row > 0:
                self.selected = (self.selected[0] - 1, self.selected[1])
                self.cells[row - 1][col].selected = True
                self.cells[row][col].selected = False
        if direction == 'down':
            if row < 9:
                self.selected = (self.selected[0] + 1, self.selected[1])
                self.cells[row + 1][col].selected = True
                self.cells[row][col].selected = False
        if direction == 'left':
            if col > 0:
                self.selected = (self.selected[0], self.selected[1] - 1)
                self.cells[row][col - 1].selected = True
                self.cells[row][col].selected = False
        if direction == 'right':
            if col < 9:
                self.selected = (self.selected[0], self.selected[1] + 1)
                self.cells[row][col + 1].selected = True
                self.cells[row][col].selected = False


class Opponent(Battlefield):
    def __init__(self, rows, cols, h_offset):
        super().__init__(rows, cols, h_offset)

        for x in range(self.rows):
            for y in range(self.cols):
                self.cells[x][y].visible = False

    def generate(self):
        opp_ships = SHIPS[:]
        while opp_ships:
            ship_len = opp_ships[0]
            direction = random.choice(['horizontal', 'vertical'])
            x, y = [random.randint(0, 9) for _ in range(2)]

            if direction == 'horizontal':
                range_x = range(max(0, x - 1), min(x + ship_len + 1, 10))
                range_y = range(max(0, y - 1), min(y + 2, 10))
                if len(range_x) < ship_len + 1 or len(range_y) < 2:
                    continue
                if any(self.cells[row][col].value for row in range_y
                       for col in range_x):
                    continue
                for num in range(x, x + ship_len):
                    self.cells[y][num].value = TARGET_REVEALED
            elif direction == 'vertical':
                range_x = range(max(0, x - 1), min(x + 2, 10))
                range_y = range(max(0, y - 1), min(y + ship_len + 1, 10))
                if len(range_x) < 2 or len(range_y) < ship_len + 1:
                    continue
                if any(self.cells[row][col].value for row in range_y
                       for col in range_x):
                    continue
                for num in range(y, y + ship_len):
                    self.cells[num][x].value = TARGET_REVEALED
            opp_ships.pop(0)

    def repeat(self):
        if self.selected:
            x, y = self.selected
            if (x, y) in self.moves:
                return True

    def shoot(self):
        if self.selected:
            x, y = self.selected
            if (x, y) not in self.moves:
                self.moves.append((x, y))
                self.cells[x][y].visible = True
                if self.cells[x][y].value:
                    self.cells[x][y].value = TARGET_HIT
                    self.hits_left -= 1
                else:
                    self.cells[x][y].value = TARGET_MISSED
                    return True


class Cell:
    color = CELL_COLOR

    def __init__(self, row, col, bf_width, bf_height, h_offset):
        self.value = None
        self.row = row
        self.col = col
        self.h_offset = h_offset
        self.bf_width = bf_width
        self.bf_height = bf_height
        self.selected = False
        self.locked = False
        self.visible = True

    def draw(self):
        gap = self.bf_width / 10
        x = self.row * gap
        y = self.col * gap
        pygame.draw.rect(WIN, self.color, (x, y + self.h_offset, gap, gap))

        if self.value and self.visible:
            text = FONT.render(self.value, True, (0, 0, 0))
            WIN.blit(text, (x + 5, y + self.h_offset - 2))

        if self.selected:
            pygame.draw.rect(WIN, SELECTED_COLOR,
                             (x, y + self.h_offset, gap, gap), 3)

        if self.locked:
            pygame.draw.rect(WIN, LOCKED_COLOR,
                             (x, y + self.h_offset, gap, gap), 3)


def draw_window(player, opp, msg, msg2):
    pygame.display.set_mode((WIN_WIDTH, WIN_HEIGHT))

    WIN.fill(BG_COLOR)

    player.draw()
    opp.draw()

    draw_text(f'Player\'s board: ({HITS-player.hits_left}/'
              f'{HITS} hits)', EDGE, EDGE)
    draw_text(f'Opponent\'s board: ({HITS-opp.hits_left}/{HITS} '
              f'hits)', EDGE,
              3 * EDGE + BF_HEIGHT + PLAYER_TEXT.get_height())
    draw_text(msg, BF_WIDTH + 6 * EDGE, EDGE)
    draw_text(msg2, BF_WIDTH + 6 * EDGE, 3*EDGE)

    pygame.display.flip()


def check_endgame(player, opp):
    if not player.hits_left:
        draw_window(player, opp, MSG_PLAYER_NO_SHIPS, MSG_OPP_WINS)
        sleep(3)
        quit()
    elif not opp.hits_left:
        draw_window(player, opp, MSG_OPP_NO_SHIPS, MSG_PLAYER_WINS)
        sleep(3)
        quit()


def draw_text(string, x, y):
    msg = FONT.render(string, True, (0, 0, 0))
    WIN.blit(msg, (x, y))


def main():
    run = True
    repeat = False
    hit = False
    pl_ships = SHIPS[:]
    pygame.display.set_caption('Battleship')
    pl_battlefield = Battlefield(10, 10, PLAYER_TEXT.get_height() + 2 * EDGE)
    opp_battlefield = Opponent(10, 10, PLAYER_TEXT.get_height() +
                               4 * EDGE + BF_HEIGHT + OPP_TEXT.get_height())

    opp_battlefield.generate()

    draw_window(pl_battlefield, opp_battlefield, MSG_LETS_PLAY, MSG_EMPTY)
    sleep(2)

    while run:
        if pl_ships:
            draw_window(pl_battlefield, opp_battlefield,
                        f'Place the ship of size {pl_ships[0]}', EMPTY_CELL)
        else:
            if repeat:
                draw_window(pl_battlefield, opp_battlefield,
                            MSG_MOVE_REPEAT, MSG_PICK_ANOTHER)
            elif hit:
                draw_window(pl_battlefield, opp_battlefield,
                            MSG_HIT, MSG_PICK_ANOTHER)
            else:
                draw_window(pl_battlefield, opp_battlefield,
                            MSG_PLAYER_TURN, MSG_PICK_CELL)

        keys = pygame.key.get_pressed()
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                run = False
            if keys[pygame.K_q]:
                run = False
            if event.type == pygame.MOUSEBUTTONDOWN:
                pos = pygame.mouse.get_pos()
                clicked_pl = pl_battlefield.get_cell(pos)
                clicked_opp = opp_battlefield.get_cell(pos)
                pl_battlefield.deselect_cells()
                opp_battlefield.deselect_cells()
                if clicked_pl and pl_ships:
                    pl_battlefield.select_cell(clicked_pl[0], clicked_pl[1])
                elif clicked_opp and not pl_ships:
                    opp_battlefield.select_cell(clicked_opp[0], clicked_opp[1])
            if event.type == pygame.KEYDOWN:
                if pl_battlefield.selected and pl_ships:
                    if event.key == pygame.K_UP:
                        pl_battlefield.move_arrows('up')
                    if event.key == pygame.K_DOWN:
                        pl_battlefield.move_arrows('down')
                    if event.key == pygame.K_LEFT:
                        pl_battlefield.move_arrows('left')
                    if event.key == pygame.K_RIGHT:
                        pl_battlefield.move_arrows('right')
                    if event.key == pygame.K_SPACE:
                        pl_battlefield.lock_cell()
                    if event.key == pygame.K_DELETE:
                        pl_battlefield.locked = []
                    if event.key == pygame.K_RETURN:
                        pl_battlefield.evaluate_selected(pl_ships)
                if opp_battlefield.selected and not pl_ships:
                    if event.key == pygame.K_UP:
                        opp_battlefield.move_arrows('up')
                    if event.key == pygame.K_DOWN:
                        opp_battlefield.move_arrows('down')
                    if event.key == pygame.K_LEFT:
                        opp_battlefield.move_arrows('left')
                    if event.key == pygame.K_RIGHT:
                        opp_battlefield.move_arrows('right')
                    if event.key == pygame.K_RETURN:
                        if opp_battlefield.repeat():
                            repeat = True
                        else:
                            repeat = False
                            player_missed = opp_battlefield.shoot()
                            check_endgame(pl_battlefield, opp_battlefield)
                            if player_missed:
                                hit = False
                                draw_window(pl_battlefield, opp_battlefield,
                                            MSG_PLAYER_MISS, MSG_OPP_TURN)
                                sleep(1)
                                pl_battlefield.opps_turn()
                                check_endgame(pl_battlefield, opp_battlefield)
                            else:
                                hit = True


if __name__ == '__main__':
    main()
